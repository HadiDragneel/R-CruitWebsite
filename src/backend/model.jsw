const use = require('@tensorflow-models/universal-sentence-encoder');

export async function getScore(qualifications, experiences) {
    const qualifications_and_experiences = qualifications.concat(experiences)
    const model = await use.load()

    const similarityScore = async (firstSentence, secondSentence, embeddings) => {
        const firstSentenceEmbeddings = embeddings.slice([firstSentence, 0], [1])
        const secondSentenceEmbeddings = embeddings.slice([secondSentence, 0], [1])
        const firstSentenceT = false
        const secondSentenceT = true
        const scoreData = await firstSentenceEmbeddings
            .matMul(secondSentenceEmbeddings, firstSentenceT, secondSentenceT)
            .data()
        return scoreData[0]
    }

    const embeddings = await model.embed(qualifications_and_experiences)

    let scores = []
    let experienceLength = experiences.length - 1
    let tempScores = []

    for (let i = 0; i < qualifications.length; i++) {

        for (let j = 0; j < experienceLength; j++) {
            const experience = experienceLength + j
            const tempScore = await similarityScore(i, experience, embeddings)

            // TODO: Cleanup demo
            console.log(`\nThe % match between
            Qualification ${i + 1}: ${qualifications_and_experiences[i]} \n
            |AND|\n
            Experience ${j + 1}: ${qualifications_and_experiences[experience]}\n
            = ${tempScore * 100}%\n`)
            tempScores.push(tempScore)
        }
        scores.push(Math.max(...tempScores))
        tempScores = []
    }

    const average = (array) => array.reduce((a, b) => a + b) / qualifications.length
    return average(scores)
}
